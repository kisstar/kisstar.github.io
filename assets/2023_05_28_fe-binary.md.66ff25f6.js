import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.e9126b17.js";const p="/images/js/js-binary.png",o="/images/js/abta.png",b=JSON.parse('{"title":"浏览器中的二进制数据操作和转换","description":"","frontmatter":{"thumbnail":"/images/js/js-binary.png","title":"浏览器中的二进制数据操作和转换","summary":"随着用户设备的升级和浏览器的版本更新，许多二进制的操作都可以放到浏览器中进行了，如 PDF 的生成、对多个文件打包下载和音视频的编解码等，以便于降低服务端压力和节省资源。","author":"Kisstar","location":"北京","date":"2023-05-28T00:00:00.000Z","categoryKeys":["frontend"],"tagKeys":["js"],"outline":"deep"},"headers":[],"relativePath":"2023/05/28/fe-binary.md","filePath":"posts/js/2023-05-28-fe-binary.md","lastUpdated":1709990470000}'),e={name:"2023/05/28/fe-binary.md"},t=l('<img style="width:100%;height:350px;" src="'+p+`" alt="JavaScript Binary"><p>随着用户设备的升级和浏览器的版本更新，许多二进制的操作都可以放到浏览器中进行了，如 PDF 的生成、对多个文件打包下载和音视频的编解码等，以便于降低服务端压力和节省资源。</p><p>到目前为止，浏览器已经提供了诸多操作二进制的数据类型，并且支持各种数据类型进行相互转换，接下来就来了解下。</p><h2 id="arraybuffer" tabindex="-1">ArrayBuffer <a class="header-anchor" href="#arraybuffer" aria-label="Permalink to &quot;ArrayBuffer&quot;">​</a></h2><p>ArrayBuffer 是一个字节数组，通常在其他语言中称为“byte array”，该对象用来表示通用的、固定长度的原始二进制数据缓冲区。</p><p>你不能直接操作 ArrayBuffer 的内容，而是要通过 TypedArray 或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。</p><h3 id="基础使用" tabindex="-1">基础使用 <a class="header-anchor" href="#基础使用" aria-label="Permalink to &quot;基础使用&quot;">​</a></h3><p>通过 ArrayBuffer 构造函数可以创建一个指定字节长度的 ArrayBuffer 对象。</p><p>它接受一个参数用于指定 ArrayBuffer 的大小（单位为字节），然后返回一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0。</p><p>如果指定的 <code>length</code> 大于 Number.MAX_SAFE_INTEGER（&gt;= 2 ** 53）或为负数，则抛出一个 RangeError 异常。</p><p>以下是一些常见的属性和方法：</p><table><thead><tr><th style="text-align:left;">属性/方法</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">ArrayBuffer.length</td><td style="text-align:left;">ArrayBuffer 构造函数的 length 属性，其值为 1</td></tr><tr><td style="text-align:left;">ArrayBuffer.isView(arg)</td><td style="text-align:left;">判断是否是一种 ArrayBuffer 视图</td></tr><tr><td style="text-align:left;">ArrayBuffer.slice(begin[, end])</td><td style="text-align:left;">和 ArrayBuffer.prototype.slice() 功能相同</td></tr><tr><td style="text-align:left;">ArrayBuffer.transfer(oldBuffer [, newByteLength])</td><td style="text-align:left;">返回一个新的 ArrayBuffer 对象，其内容取自 oldBuffer 中的数据</td></tr><tr><td style="text-align:left;">ArrayBuffer.prototype.slice(begin[, end])</td><td style="text-align:left;">返回一个新的 ArrayBuffer ，它的内容是这个 ArrayBuffer 的字节副本</td></tr><tr><td style="text-align:left;">ArrayBuffer.prototype.byteLength</td><td style="text-align:left;">只读属性，表示 ArrayBuffer 的 byte 的大小</td></tr></tbody></table><h3 id="和数组的区别" tabindex="-1">和数组的区别 <a class="header-anchor" href="#和数组的区别" aria-label="Permalink to &quot;和数组的区别&quot;">​</a></h3><p>需要注意的是字节数组其实和我们平时使用的普通数组没有共性，相反存在着明显的异同点：</p><ul><li>它正好占用了内存中的那么多空间。</li><li>它的长度是固定的，我们无法增加或减少它的长度。</li><li>要访问单个字节，需要另一个“视图”对象，而不是直接使用索引。</li></ul><p>事实上，它就是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(buffer.byteLength); </span><span style="color:#6A737D;">// 4</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBuffer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(buffer.byteLength); </span><span style="color:#6A737D;">// 4</span></span></code></pre></div><p>如上所示，它会分配一个长度为 4 字节的连续内存空间，并用 0 进行预填充。</p><p>当需要对字节数组进行操作时，通常我们会使用类型数组对象。类型数组对象就像是一副“眼镜”，其本身并不存储任何东西。</p><h2 id="typedarray" tabindex="-1">TypedArray <a class="header-anchor" href="#typedarray" aria-label="Permalink to &quot;TypedArray&quot;">​</a></h2><p>类型化数组（TypedArray）对象描述了一个底层的二进制数据缓冲区的一个类数组视图（view），借此我们操作 ArrayBuffer 的内容。</p><h3 id="基础介绍" tabindex="-1">基础介绍 <a class="header-anchor" href="#基础介绍" aria-label="Permalink to &quot;基础介绍&quot;">​</a></h3><p>事实上，没有名为 TypedArray 的全局属性，也没有一个名为 TypedArray 的构造函数。相反，有许多不同的全局属性，它们的值是特定元素类型的类型化数组构造函数：</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">单个元素值的范围</th><th style="text-align:left;">大小(bytes)</th><th style="text-align:left;">描述</th><th style="text-align:left;">Web IDL 类型</th><th style="text-align:left;">C 语言中的等价类型</th></tr></thead><tbody><tr><td style="text-align:left;">Int8Array</td><td style="text-align:left;">-128 to 127</td><td style="text-align:left;">1</td><td style="text-align:left;">8 位二进制有符号整数</td><td style="text-align:left;">byte</td><td style="text-align:left;">int8_t</td></tr><tr><td style="text-align:left;">Uint8Array</td><td style="text-align:left;">0 to 255</td><td style="text-align:left;">1</td><td style="text-align:left;">8 位无符号整数（超出范围后从另一边界循环）</td><td style="text-align:left;">octet</td><td style="text-align:left;">uint8_t</td></tr><tr><td style="text-align:left;">Uint8ClampedArray</td><td style="text-align:left;">0 to 255</td><td style="text-align:left;">1</td><td style="text-align:left;">8 位无符号整数（超出范围后为边界值）</td><td style="text-align:left;">octet</td><td style="text-align:left;">uint8_t</td></tr><tr><td style="text-align:left;">Int16Array</td><td style="text-align:left;">-32768 to 32767</td><td style="text-align:left;">2</td><td style="text-align:left;">16 位二进制有符号整数</td><td style="text-align:left;">short</td><td style="text-align:left;">int16_t</td></tr><tr><td style="text-align:left;">Uint16Array</td><td style="text-align:left;">0 to 65535</td><td style="text-align:left;">2</td><td style="text-align:left;">16 位无符号整数 unsigned</td><td style="text-align:left;">short</td><td style="text-align:left;">uint16_t</td></tr><tr><td style="text-align:left;">Int32Array</td><td style="text-align:left;">-2147483648 to 2147483647</td><td style="text-align:left;">4</td><td style="text-align:left;">32 位二进制有符号整数</td><td style="text-align:left;">long</td><td style="text-align:left;">int32_t</td></tr><tr><td style="text-align:left;">Uint32Array</td><td style="text-align:left;">0 to 4294967295</td><td style="text-align:left;">4</td><td style="text-align:left;">32 位无符号整数 unsigned</td><td style="text-align:left;">long</td><td style="text-align:left;">uint32_t</td></tr><tr><td style="text-align:left;">Float32Array</td><td style="text-align:left;">1.2×10-38 to 3.4×1038</td><td style="text-align:left;">4</td><td style="text-align:left;">32 位 IEEE 浮点数（7 位有效数字，如 1.1234567） unrestricted</td><td style="text-align:left;">float</td><td style="text-align:left;">float</td></tr><tr><td style="text-align:left;">Float64Array</td><td style="text-align:left;">5.0×10-324 to 1.8×10308</td><td style="text-align:left;">8</td><td style="text-align:left;">64 位 IEEE 浮点数（16 有效数字，如 1.123...15) unrestricted</td><td style="text-align:left;">double</td><td style="text-align:left;">double</td></tr><tr><td style="text-align:left;">BigInt64Array</td><td style="text-align:left;">-263 to 263-1</td><td style="text-align:left;">8</td><td style="text-align:left;">64 位二进制有符号整数</td><td style="text-align:left;">bigint</td><td style="text-align:left;">int64_t (signed long long)</td></tr><tr><td style="text-align:left;">BigUint64Array</td><td style="text-align:left;">0 to 264-1</td><td style="text-align:left;">8</td><td style="text-align:left;">64 位无符号整数</td><td style="text-align:left;">bigint</td><td style="text-align:left;">uint64_t (unsigned long long)</td></tr></tbody></table><p>如上的构造函数都可以接受多种参数，比如传入 <code>length</code> 参数时，一个内部的数组缓冲区会被创建在内存中，该缓存区的大小是传入的 <code>length</code> 乘以数组中每个元素的字节数（BYTES_PER_ELEMENT），每个元素的值都为 0。</p><h3 id="操作字节数组" tabindex="-1">操作字节数组 <a class="header-anchor" href="#操作字节数组" aria-label="Permalink to &quot;操作字节数组&quot;">​</a></h3><p>除了上面说的一种参数外，此处主要说的是：当传入一个 <code>buffer</code> 参数，或者再另外加上可选参数 <code>byteOffset</code> 和 <code>length</code> 时，一个新的类型化数组视图将会被创建，并可用于呈现传入的 ArrayBuffer 实例。</p><p>其中，<code>byteOffset</code> 和 <code>length</code> 参数指定了类型化数组视图将要暴露的内存范围。如果两者都未传入，那么整个 <code>buffer</code> 都会被呈现；如果仅仅忽略 <code>length</code>，那么 <code>buffer</code> 中偏移了 <code>byteOffset</code> 后剩下的 <code>buffer</code> 将会被呈现。</p><p>比如我们先创建一个 16 字节的字节数组，然后分别将其传递给 Uint8Array、Uint16Array、Uint32Array 和 Float64Array 等类型化数组：</p><p><img src="`+o+`" alt="abta"></p><p>然后通过视图，我们就可以写入值或遍历字节数组：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 创建一个长度为 16 的 buffer</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">view</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Uint32Array</span><span style="color:#E1E4E8;">(buffer); </span><span style="color:#6A737D;">// 将 buffer 视为一个 32 位整数的序列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 写入一个值</span></span>
<span class="line"><span style="color:#E1E4E8;">view[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">123456</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 遍历值</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">num</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> view) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(num); </span><span style="color:#6A737D;">// 123456，然后 0，0，0（一共 4 个值）</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBuffer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">16</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 创建一个长度为 16 的 buffer</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">view</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Uint32Array</span><span style="color:#24292E;">(buffer); </span><span style="color:#6A737D;">// 将 buffer 视为一个 32 位整数的序列</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 写入一个值</span></span>
<span class="line"><span style="color:#24292E;">view[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">123456</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 遍历值</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">num</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">of</span><span style="color:#24292E;"> view) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">alert</span><span style="color:#24292E;">(num); </span><span style="color:#6A737D;">// 123456，然后 0，0，0（一共 4 个值）</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="dataview" tabindex="-1">DataView <a class="header-anchor" href="#dataview" aria-label="Permalink to &quot;DataView&quot;">​</a></h2><p>除了 TypedArray 外，通过 DataView 视图也能操作字节数组，它是一个可以从二进制 ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。</p><p>它可以接受一个 <code>buffer</code> 参数，或者再另外加上可选参数 <code>byteOffset</code> 和 <code>byteLength</code> 时，一个表示指定数据缓存区的新 DataView 对象将会被创建。</p><p>你可以把返回的对象想象成一个二进制字节缓存区的“解释器”——它知道如何在读取或写入时正确地转换字节码。这意味着它能在二进制层面处理整数与浮点转化、字节顺序等其他有关的细节问题。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 4 个字节的二进制数组，每个都是最大值 255</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Uint8Array</span><span style="color:#E1E4E8;">([</span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">]).buffer;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">dataView</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DataView</span><span style="color:#E1E4E8;">(buffer);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在偏移量为 0 处获取 8 位数字</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(dataView.</span><span style="color:#B392F0;">getUint8</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// 255</span></span>
<span class="line"><span style="color:#6A737D;">// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(dataView.</span><span style="color:#B392F0;">getUint16</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// 65535（最大的 16 位无符号整数）</span></span>
<span class="line"><span style="color:#6A737D;">// 在偏移量为 0 处获取 32 位数字</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(dataView.</span><span style="color:#B392F0;">getUint32</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// 4294967295（最大的 32 位无符号整数）</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">dataView.</span><span style="color:#B392F0;">setUint32</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 将 4 个字节的数字设为 0，即将所有字节都设为 0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 4 个字节的二进制数组，每个都是最大值 255</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Uint8Array</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">]).buffer;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">dataView</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DataView</span><span style="color:#24292E;">(buffer);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在偏移量为 0 处获取 8 位数字</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(dataView.</span><span style="color:#6F42C1;">getUint8</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)); </span><span style="color:#6A737D;">// 255</span></span>
<span class="line"><span style="color:#6A737D;">// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(dataView.</span><span style="color:#6F42C1;">getUint16</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)); </span><span style="color:#6A737D;">// 65535（最大的 16 位无符号整数）</span></span>
<span class="line"><span style="color:#6A737D;">// 在偏移量为 0 处获取 32 位数字</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(dataView.</span><span style="color:#6F42C1;">getUint32</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)); </span><span style="color:#6A737D;">// 4294967295（最大的 32 位无符号整数）</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">dataView.</span><span style="color:#6F42C1;">setUint32</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 将 4 个字节的数字设为 0，即将所有字节都设为 0</span></span></code></pre></div><p>可见 DataView 是在 ArrayBuffer 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。</p><h2 id="blob" tabindex="-1">Blob <a class="header-anchor" href="#blob" aria-label="Permalink to &quot;Blob&quot;">​</a></h2><p>字节数组不仅能够通过类型数组和 DataView 视图进行操作，还能传递给 Blob 构造函数，然后得到一个新创建的 Blob 对象，其内容由参数中给定的数组拼接组成。</p><h3 id="基础-api" tabindex="-1">基础 API <a class="header-anchor" href="#基础-api" aria-label="Permalink to &quot;基础 API&quot;">​</a></h3><p>Blob 对象表示一个不可变、原始数据的类文件对象，它表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了 blob 的功能并将其扩展以支持用户系统上的文件。</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">API</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">属性</td><td style="text-align:left;">size（只读）</td><td style="text-align:left;">数据的大小（字节）</td></tr><tr><td style="text-align:left;">属性</td><td style="text-align:left;">type（只读）</td><td style="text-align:left;">数据的 MIME 类型。如果类型未知，则该值为空字符串</td></tr><tr><td style="text-align:left;">方法</td><td style="text-align:left;">arrayBuffer()</td><td style="text-align:left;">返回一个 Promise，数据为二进制格式的 ArrayBuffer</td></tr><tr><td style="text-align:left;">方法</td><td style="text-align:left;">slice()</td><td style="text-align:left;">返回一个新的 Blob 对象，包含指定范围的数据</td></tr><tr><td style="text-align:left;">方法</td><td style="text-align:left;">text()</td><td style="text-align:left;">返回一个 Promise，包含所有内容的 UTF-8 格式的字符串</td></tr></tbody></table><p>当用字节数组创建 Blob 对象时：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Uint8Array</span><span style="color:#E1E4E8;">([</span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">]).buffer;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">blob</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Blob</span><span style="color:#E1E4E8;">([buffer]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(blob.size);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Uint8Array</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">]).buffer;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">blob</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Blob</span><span style="color:#24292E;">([buffer]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(blob.size);</span></span></code></pre></div><h2 id="filereader" tabindex="-1">FileReader <a class="header-anchor" href="#filereader" aria-label="Permalink to &quot;FileReader&quot;">​</a></h2><p>常见的一种从 Blob 中读取内容的方法是使用 FileReader，FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p><p>以下代码将 Blob 的内容作为类型化数组读取：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">reader</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FileReader</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">reader.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;loadend&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// reader.result 包含被转化为类型化数组的 Blob 中的内容</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(reader.result);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">reader.</span><span style="color:#B392F0;">readAsArrayBuffer</span><span style="color:#E1E4E8;">(blob);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">reader</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FileReader</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">reader.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;loadend&#39;</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// reader.result 包含被转化为类型化数组的 Blob 中的内容</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(reader.result);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">reader.</span><span style="color:#6F42C1;">readAsArrayBuffer</span><span style="color:#24292E;">(blob);</span></span></code></pre></div><p>另一种读取 Blob 中内容的方式是使用 Response 对象（Fetch API 的 Response 接口）。下述代码将 Blob 中的内容读取为文本：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">text</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Response</span><span style="color:#E1E4E8;">(blob).</span><span style="color:#B392F0;">text</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">text</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Response</span><span style="color:#24292E;">(blob).</span><span style="color:#6F42C1;">text</span><span style="color:#24292E;">();</span></span></code></pre></div><p>另外，通过使用 FileReader 的其他方法可以把 Blob 读取为数据 URL 或者对象 URL。</p><h2 id="canvas" tabindex="-1">Canvas <a class="header-anchor" href="#canvas" aria-label="Permalink to &quot;Canvas&quot;">​</a></h2><p>无论是数据 URL 还是对象 URL 的图片数据都可以传递给 <code>&lt;image&gt;</code> 标签进行展示，这在上传图片前进行预览时会很有用，而图片则又可以交由 Canvas 绘制。</p><p>Canvas API 提供了一个通过 JavaScript 和 HTML 的 <code>&lt;canvas&gt;</code> 元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">canvas</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;canvas&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">canvas</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">style</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;display:none;&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">img</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;source&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;demo.jpg&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">width</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;300&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">height</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;227&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">canvas</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;canvas&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">canvas</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">style</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;display:none;&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">img</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;source&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">src</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;demo.jpg&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">width</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;300&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">height</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;227&quot;</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>其 API 中的 <code>CanvasRenderingContext2D.drawImage()</code> 方法提供了多种在画布（Canvas）上绘制图像的方式。</p><p>下面从原图像坐标 (33,71) 处截取一个宽度为 104 高度为 124 的图像。并将其绘制到画布的 (21, 20) 坐标处，并将其缩放为宽 87、高 104 的图像：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">canvas</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;canvas&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">image</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;source&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">ctx</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> canvas.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;2d&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">image.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;load&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ctx.</span><span style="color:#B392F0;">drawImage</span><span style="color:#E1E4E8;">(image, </span><span style="color:#79B8FF;">33</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">71</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">104</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">124</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">21</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">87</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">104</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">canvas</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;canvas&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">image</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;source&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">ctx</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> canvas.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;2d&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">image.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;load&#39;</span><span style="color:#24292E;">, </span><span style="color:#E36209;">e</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  ctx.</span><span style="color:#6F42C1;">drawImage</span><span style="color:#24292E;">(image, </span><span style="color:#005CC5;">33</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">71</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">104</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">124</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">21</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">87</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">104</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>而根据 HTMLCanvasElement 中的 <code>toBlob()</code> 和 <code>toDataURL()</code> 则又可以得到对应的 Blob 对象和数据 URL。</p><h2 id="demo" tabindex="-1">Demo <a class="header-anchor" href="#demo" aria-label="Permalink to &quot;Demo&quot;">​</a></h2><p>预览本地图片：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 通过 input[type=file] 选取本地文件</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">fileList</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> e.target.files;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">file</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fileList[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#6A737D;">// 使用 FileReader 读取文件对象</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">reader</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FileReader</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">reader.</span><span style="color:#B392F0;">onload</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">imgUrl</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> event.target.result;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 此处得到的 base64 的地址可直接提供过 img 标签进行加载预览</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#6A737D;">// 把文件对象作为一个 dataURL</span></span>
<span class="line"><span style="color:#E1E4E8;">reader.</span><span style="color:#B392F0;">readAsDataURL</span><span style="color:#E1E4E8;">(file);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 通过 input[type=file] 选取本地文件</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">fileList</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> e.target.files;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">file</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fileList[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#6A737D;">// 使用 FileReader 读取文件对象</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">reader</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FileReader</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">reader.</span><span style="color:#6F42C1;">onload</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#E36209;">event</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">imgUrl</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> event.target.result;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 此处得到的 base64 的地址可直接提供过 img 标签进行加载预览</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#6A737D;">// 把文件对象作为一个 dataURL</span></span>
<span class="line"><span style="color:#24292E;">reader.</span><span style="color:#6F42C1;">readAsDataURL</span><span style="color:#24292E;">(file);</span></span></code></pre></div><p>将字符串内容下载为一个文件：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">json</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  heelo: </span><span style="color:#9ECBFF;">&#39;world&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">josnStr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">JSON</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(json, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">jsonBlob</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Blob</span><span style="color:#E1E4E8;">([josnStr], { type: </span><span style="color:#9ECBFF;">&#39;application/json&#39;</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">objectURL</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">URL</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">createObjectURL</span><span style="color:#E1E4E8;">(jsonBlob);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">aEl</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;a&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">aEl.download </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;hello.json&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">aEl.rel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;noopener&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">aEl.href </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> objectURL;</span></span>
<span class="line"><span style="color:#E1E4E8;">aEl.</span><span style="color:#B392F0;">dispatchEvent</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MouseEvent</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;click&#39;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#79B8FF;">URL</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">revokeObjectURL</span><span style="color:#E1E4E8;">(objectURL);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">json</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  heelo: </span><span style="color:#032F62;">&#39;world&#39;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">josnStr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">JSON</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">stringify</span><span style="color:#24292E;">(json, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">jsonBlob</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Blob</span><span style="color:#24292E;">([josnStr], { type: </span><span style="color:#032F62;">&#39;application/json&#39;</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">objectURL</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">URL</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">createObjectURL</span><span style="color:#24292E;">(jsonBlob);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">aEl</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;a&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">aEl.download </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;hello.json&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">aEl.rel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;noopener&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">aEl.href </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> objectURL;</span></span>
<span class="line"><span style="color:#24292E;">aEl.</span><span style="color:#6F42C1;">dispatchEvent</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MouseEvent</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;click&#39;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#005CC5;">URL</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">revokeObjectURL</span><span style="color:#24292E;">(objectURL);</span></span></code></pre></div><h2 id="附录" tabindex="-1">附录 <a class="header-anchor" href="#附录" aria-label="Permalink to &quot;附录&quot;">​</a></h2><ul><li><strong>Data URL</strong></li></ul><p>Data URL，即前缀为 data: 协议的 URL，其允许内容创建者向文档中嵌入小文件。</p><p>Data URL 由四个部分组成：前缀（data:）、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span></span></code></pre></div><ul><li><strong>Object URL</strong></li></ul><p><code>URL.createObjectURL()</code> 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个新的 URL 对象表示指定的 File 对象或 Blob 对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 参数 object 为 File 对象、Blob 对象或者 MediaSource 对象</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">objectURL</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">URL</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">createObjectURL</span><span style="color:#E1E4E8;">(object);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 参数 object 为 File 对象、Blob 对象或者 MediaSource 对象</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">objectURL</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">URL</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">createObjectURL</span><span style="color:#24292E;">(object);</span></span></code></pre></div><p>在每次调用 createObjectURL() 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。</p><p>浏览器在 document 卸载的时候，会自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p><h2 id="refs" tabindex="-1">Refs <a class="header-anchor" href="#refs" aria-label="Permalink to &quot;Refs&quot;">​</a></h2><ul><li><a href="https://zh.javascript.info/arraybuffer-binary-arrays" target="_blank" rel="noreferrer">ArrayBuffer，二进制数组</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">TypedArray - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noreferrer">DataView - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noreferrer">Blob - Web API 接口参考 | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noreferrer">FileReader - Web API 接口参考 | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer">Canvas - Web API 接口参考 | MDN</a></li></ul>`,77),r=[t];function c(y,E,i,d,F,g){return a(),n("div",null,r)}const h=s(e,[["render",c]]);export{b as __pageData,h as default};
