import{_ as e,o as p,c as t,Q as a}from"./chunks/framework.eecc699f.js";const n="/images/computer-graphics/opengl-pipeline.png",D=JSON.parse('{"title":"OpenGL 的图形渲染管线","description":"","frontmatter":{},"headers":[],"relativePath":"computer-graphics/opengl-pipeline.md","filePath":"computer-graphics/opengl-pipeline.md"}'),o={name:"computer-graphics/opengl-pipeline.md"},r=a('<h1 id="opengl-的图形渲染管线" tabindex="-1">OpenGL 的图形渲染管线 <a class="header-anchor" href="#opengl-的图形渲染管线" aria-label="Permalink to &quot;OpenGL 的图形渲染管线&quot;">​</a></h1><p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。</p><p>3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的 3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素。</p><p>图形渲染管线接受一组 3D 坐标，然后把它们转变为你屏幕上的有色 2D 像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在 GPU 上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器。</p><p><img src="'+n+'" alt="OpenGL pipeline"></p><p>首先，我们以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据（Vertex Data）；顶点数据是一系列顶点的集合。</p><blockquote><p>一个顶点（Vertex）是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据，但是简单起见，我们假定每个顶点只由一个 3D 位置（译注 1）和一些颜色值组成的吧。</p></blockquote><p>图形渲染管线的第一个部分是顶点着色器（Vertex Shader），它把一个单独的顶点作为输入。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p>顶点着色器阶段的输出可以选择性地传递给几何着色器（Geometry Shader）。几何着色器将一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的（或其他）图元来生成其他形状。在这个例子中，它从给定的形状中生成第二个三角形。</p><p>图元装配（Primitive Assembly）阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p><p>图元装配阶段的输出会被传入光栅化阶段（Rasterization Stage），这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器（Fragment Shader）使用的片段（Fragment）。在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><blockquote><p>OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。</p></blockquote><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做 Alpha 测试和混合（Blending）阶段。这个阶段检测片段的对应的深度（和模板（Stencil））值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合（Blend）。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>',14),i=[r];function l(c,s,_,m,d,h){return p(),t("div",null,i)}const u=e(o,[["render",l]]);export{D as __pageData,u as default};
