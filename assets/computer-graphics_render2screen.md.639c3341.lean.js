import{_ as e,o as t,c as r,O as o}from"./chunks/framework.2a7ed5c6.js";const a="/images/computer-graphics/coordinate.png",s="/images/computer-graphics/rasterization.png",c="/images/computer-graphics/rasterization-theory.png",_=JSON.parse('{"title":"图像是如何渲染到屏幕的","description":"","frontmatter":{},"headers":[],"relativePath":"computer-graphics/render2screen.md","filePath":"computer-graphics/render2screen.md","lastUpdated":1743313216000}'),i={name:"computer-graphics/render2screen.md"};function n(m,p,l,d,u,g){return t(),r("div",null,p[0]||(p[0]=[o('<h1 id="图像是如何渲染到屏幕的" tabindex="-1">图像是如何渲染到屏幕的 <a class="header-anchor" href="#图像是如何渲染到屏幕的" aria-label="Permalink to &quot;图像是如何渲染到屏幕的&quot;">​</a></h1><p>图形渲染是计算机图形学领域的核心技术之一，它通过将三维模型转化为二维图像，实现了各种视觉效果的呈现。无论是电影特效、视频游戏还是虚拟现实，都离不开图形渲染的应用。</p><p>模型是用语言或者数据结构进行严格定义的三维物体或虚拟场景，它包括几何、视点、纹理、照明等信息。</p><p>没有模型，图形就无从谈起，建模是计算机图形学各项工作的基础和前提，建模技术的核心是根据研究对象的三维空间信息构造其立体模型，尤其是几何模型，并利用相关建模软件或编程语言生成该模型的图形显示，然后对其进行处理。</p><p>通常，在构造和显示一个场景的过程中会使用几个不同的笛卡儿参照系。</p><p><img src="'+a+'" alt="coordinate"></p><p>首先在各自的参照系中构造每一对象的形状，比如树或家具。这些坐标系称为建模坐标系，有时也称为局部坐标系，或主坐标系。一旦指定了单个物体的形状，我们可将对象放到称为世界坐标系的场景参照系中的适当位置。这一步涉及从单独的建模坐标系到世界坐标系的指定位置和方向的变换。</p><blockquote><p>可以简单理解为局部坐标系描述的是形状，世界坐标系引入了位置和方向。</p></blockquote><p>例如，我们可以在各个独立的建模坐标系中定义自行车的零件（车轮、车架、坐垫、车把手、齿轮、链条、踏板等），然后将这些零件在世界坐标系中装配起来。如果两个车轮尺寸相同，我们只需要在局部坐标系中定义一个车轮。该车轮装配到世界坐标系的两个位置。</p><p>如果场景不是很复杂，对象的各部分可以直接在世界坐标系中建立，从而跳过建模坐标和建模变换两步。</p><blockquote><p>在建模坐标系和世界坐标系中可以使用任何浮点数或整数值来给出几何描述，而不受特定输出设备的约束。</p></blockquote><p>在描述好场景的所有部分之后，要将该场景的世界坐标描述经各种处理变换到一个或多个输出设备参照系来显示。这个过程称为观察流水线。</p><p>为此，世界坐标系的位置首先转换到与我们要对场景进行观察所对应的观察坐标系，该转换依据假想照相机的位置和方向来进行。对象位置变换到该场景的一个二维投影，该投影对应于我们在输出屏幕上看到的结果。</p><p>随后，将通过一个投影矩阵把顶点从观察空间转换到一个裁剪空间下，识别可见面并清除在显示设备上观察边界之外的图形部分。</p><p>接着，将该场景存入规范化坐标系，其坐标范围从 -1 到 1 或从 0 到 1，这依赖于不同的系统。规范化坐标系也称为规范化设备坐标系，使用该表示可使图形软件包与任何特定输出设备的坐标范围无关。</p><p>最后，图形经扫描转换到光栅系统的刷新缓存中进行显示。显示设备的坐标系称为设备坐标系，或对视频监视器而言称为屏幕坐标系。</p><blockquote><p>将顶点坐标从模型（局部）空间变换到世界空间，称为模型变换。</p><p>将世界空间中的顶点坐标变换到观察空间，称为视图变换。</p><p>将观察空间中的顶点坐标变换到裁剪空间，称为投影变换。</p><p>将裁剪空间中的顶点坐标变换到规范化设备坐标系，称为透视除法。</p><p>将规范化设备坐标系中的顶点坐标变换到屏幕坐标系，称为视口变换（Viewport Transform）。</p></blockquote><p>当这些逐三角形和逐顶点的操作完成之后，生成的结果就会被输入到光栅化阶段。光栅化，是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程。</p><p>栅格化将顶点数据转换为片元，片元中的每一个元素对应于帧缓冲区中的一个像素。如图：</p><p><img src="'+s+'" alt="Rasterization"></p><p>栅格化的本质是坐标变换、几何离散化，如图：</p><p><img src="'+c+'" alt="Rasterization theory"></p><p>栅格化其实是一种将几何图元变为二维图像的过程。该过程包含了两部分的工作。第一部分工作：决定窗口坐标中的哪些整型栅格区域被基本图元占用；第二部分工作：分配一个颜色值和一个深度值到各个区域。</p><p>每个物体都会被轮流处理，最终生成一副图像，然后显示在屏幕上。</p>',24)]))}const f=e(i,[["render",n]]);export{_ as __pageData,f as default};
