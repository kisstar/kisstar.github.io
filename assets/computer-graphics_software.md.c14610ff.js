import{_ as e,o as a,c as t,Q as r}from"./chunks/framework.e9126b17.js";const p="/images/computer-graphics/opengl.png",o="/images/computer-graphics/architecture-notes.png",n="/images/computer-graphics/rhi.png",_=JSON.parse('{"title":"图形软件","description":"","frontmatter":{},"headers":[],"relativePath":"computer-graphics/software.md","filePath":"computer-graphics/software.md","lastUpdated":1713579991000}'),i={name:"computer-graphics/software.md"},l=r('<h1 id="图形软件" tabindex="-1">图形软件 <a class="header-anchor" href="#图形软件" aria-label="Permalink to &quot;图形软件&quot;">​</a></h1><p>图形软件有两个大类：专用软件包和通用编程软件包和通用图形编程软件包。</p><p>专用图形软件包是为非程序员设计的，使得他们在某些应用中能用来生成图形、表格而不必关心显示所需的图形函数。相反，通用图形编程软件包提供一个可用于 C、C++、Java 或 Fortran 等高级程序设计语言的图形函数库。</p><h2 id="图形功能" tabindex="-1">图形功能 <a class="header-anchor" href="#图形功能" aria-label="Permalink to &quot;图形功能&quot;">​</a></h2><p>图形的基本构造块称为图形输出图元。它们包括字符串和几何成分，如点、直线、曲线、填充区域（通常为多边形）以及由彩色阵列定义的形状。此外，有些图形软件包提供对复杂形体（如球体、锥体和柱体）的显示函数。生成输出图元的函数提供了构造图形的基本工具。</p><p>属性是输出图元的特性。也就是说，属性描述一个特定图元是怎样显示出来的。它们包括颜色设定、线型或文本格式及区域填充图案等。</p><p>我们可以使用几何变换来改变场景中一个对象的大小、位置或方向。某些图形包给出一组函数实现建模变换，将建模坐标系中给出的对象描述组织成场景。这些图形软件包通常提供描述复杂对象（如电子线路或自行车）的树形结构。</p><p>另外一些软件包仅简单地提供几何变换函数，而将建模细节留给了程序员。</p><p>利用对象形状及其属性的描述函数构造场景之后，图形软件包将选定视图投影到输出设备。观察变换用来指定将要显示的视图、使用的投影类型及在输出显示区域出现的范围。另有一些函数通过指定位置、大小和结构来管理屏幕显示范围。对于三维场景还要判定可见对象并应用光照条件。</p><h2 id="软件标准" tabindex="-1">软件标准 <a class="header-anchor" href="#软件标准" aria-label="Permalink to &quot;软件标准&quot;">​</a></h2><p>标准化图形软件的最主要目标是可移植性。当软件包按标准图形功能设计时，软件可以方便地从一个硬件系统移植到另一个，并且用于不同的实现和应用。如果没有标准，那么不经过大量的重新编写，常常不能将一个为硬件系统设计的程序移植到另一个系统。</p><p>在 1984 年推出的图形核心系统（GKS）成为国际标准化组织（ISO）和许多国家的标准化组织包括美国国家标准化组织接受的第一个图形软件标准。</p><p>虽然 GKS 最初的设计是一个二维图形软件包，但三维 GKS 扩展随后也开发出来。已制定出来并得到标准化组织批准的第二个图形软件标准是程序员级的分层结构交互图形标准（PHIGS），它是对 GKS 的扩充。</p><p>PHIGS 提供了层次式对象建模、颜色设定、表面绘制和图形管理等功能。此后，PHIGS 的扩充称为 PHIGS+，用于提供 PHIGS 所没有的三维表面明暗处理功能。</p><p>随着 GKS 和 PHIGS 得到开发，SGI 公司的图形工作站逐渐流行。这些工作站使用称为 GL 的函数集，GL 很快成为图形界广泛使用的图形软件包。因此 GL 成为事实上的图形标准。</p><p>GL 函数为快速、实时绘制而设计，很快便扩展到其他硬件系统中。结果，作为 GL 的与硬件无关的版本，OpenGL 在 20 世纪 90 年代早期就制定出来。这一图形软件包现在由代表许多图形公司和组织的 OpenGL 结构评议委员会进行维护和更新。</p><h2 id="opengl" tabindex="-1">OpenGL <a class="header-anchor" href="#opengl" aria-label="Permalink to &quot;OpenGL&quot;">​</a></h2><p>通常，我们提到 OpenGL 时会觉得它是一个包含了一系列可以操作图形、图像的函数库。实际上，OpenGL 本身并不是一个 API，它仅仅是一个由 Khronos 组织制定并维护的规范。</p><p><img src="'+p+'" alt="OpenGL"></p><p>OpenGL 规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由 OpenGL 库的开发者自行决定。</p><blockquote><p>由于 OpenGL 的大多数实现都是由显卡厂商编写的，当产生一个 bug 时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的 OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动。</p></blockquote><h2 id="webgpu" tabindex="-1">WebGPU <a class="header-anchor" href="#webgpu" aria-label="Permalink to &quot;WebGPU&quot;">​</a></h2><p>与 OpenGL 之类的东西相比，WebGPU 比原生级更好。它超越了 OpenGL、WebGL 和老一代 DirectX API 等技术更快、更强、设计更好。</p><p>个人电脑或智能手机通常包含两个计算单元：CPU（用于中央处理单元）和 GPU（图形处理单元）。在对应用程序进行编程时，主要为 CPU 编写指令。这就是大多数编程语言的用途。</p><p><img src="'+o+'" alt="Architecture"></p><p>如果希望应用程序在 GPU 上执行指令（例如，渲染 3D 图像），则 CPU 代码必须向 GPU 的驱动程序发送指令。图形 API 是 CPU 代码用来与 GPU 对话的编程接口。</p><p>存在许多这样的 API，例如，您可能听说过 OpenGL、DirectX、Vulkan 或 Metal。</p><blockquote><p>理论上，任何人都可以发明自己的图形 API。每个 GPU 供应商都有自己的底层协议，供其驱动程序与硬件对话，在此基础上实现了更常见的 API（通常与驱动程序一起提供）。</p></blockquote><p>WebGPU 的图形 API 设计用于提供对 GPU 的统一访问，无论 GPU 供应商和应用程序运行的操作系统是什么。</p><p><img src="'+n+'" alt="WebGPU"></p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>通常，图形程序设计软件包要求坐标描述在笛卡儿坐标系中给出。场景的每个对象可定义在单独的建模笛卡儿坐标系中，然后映射到世界坐标系，并构造该场景。三维对象从世界坐标系投影到二维平面的规范化设备坐标系中，然后再变换到最终的显示设备坐标系。从建模坐标到规范化设备坐标的变换，是独立于应用中使用的特定设备的。设备驱动器则用于将规范化坐标变换到整数设备坐标。</p><p>图形编程软件包的函数可分为几类：输出图元、属性、几何和建模变换、观察变换、结构操作、输入函数、图形-结构操作和控制操作。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/biezhihua/article/details/78926849" target="_blank" rel="noreferrer">Unity3D - Shader - 模型、世界、观察、裁剪空间坐标转换 - CSDN 博客</a></li><li><a href="https://www.jianshu.com/p/4ae450699c0c" target="_blank" rel="noreferrer">【图形学基础】空间坐标系基础知识 - 简书</a></li><li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/" target="_blank" rel="noreferrer">坐标系统 - LearnOpenGL CN</a></li><li><a href="https://eliemichel.github.io/LearnWebGPU/introduction.html" target="_blank" rel="noreferrer">Introduction - Learn WebGPU for C++ documentation</a></li><li><a href="https://learnopengl-cn.github.io/intro/" target="_blank" rel="noreferrer">简介 - LearnOpenGL CN</a></li></ul>',35),c=[l];function s(h,G,u,d,P,b){return a(),t("div",null,c)}const g=e(i,[["render",s]]);export{_ as __pageData,g as default};
