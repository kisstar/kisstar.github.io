import{_ as e,o as i,c as t,O as l}from"./chunks/framework.97d8791f.js";const r="/assets/image-1.7be0011a.png",o="/assets/image-2.fd3adf3a.png",s="/assets/image-6.20217e01.png",n="/assets/image-4.5ef753d3.png",p="/assets/image-3.3de88d9d.png",c="/assets/image-5.afcceaf6.png",d="/assets/image-9.ca1cfa1b.png",h="/assets/image-7.9fc835a6.png",m="/assets/image-8.86f628ea.png",x=JSON.parse('{"title":"UML 类图和时序图","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"design-pattern/uml-diagram.md","filePath":"design-pattern/uml-diagram.md","lastUpdated":1748150628000}'),g={name:"design-pattern/uml-diagram.md"};function u(f,a,b,_,k,q){return i(),t("div",null,a[0]||(a[0]=[l('<h1 id="uml-类图和时序图" tabindex="-1">UML 类图和时序图 <a class="header-anchor" href="#uml-类图和时序图" aria-label="Permalink to &quot;UML 类图和时序图&quot;">​</a></h1><p>UML 类图是软件工程中不可或缺的一部分，它是一种静态结构图，用于展示系统中类的内部结构及类之间的关系。</p><h2 id="类图的组成部分" tabindex="-1">类图的组成部分 <a class="header-anchor" href="#类图的组成部分" aria-label="Permalink to &quot;类图的组成部分&quot;">​</a></h2><p>类图由以下几个组成部分组成：</p><ul><li>类名：类的名称</li><li>属性：类的属性</li><li>方法：类的方法</li><li>关系：类之间的关系</li></ul><p>属性和方法前面可以有可见性修饰符，例如：</p><ul><li><code>+</code>：表示 public</li><li><code>#</code>：表示 protected</li><li><code>-</code>：表示 private</li><li><code>~</code>：表示 package-private</li></ul><h2 id="类之间的关系" tabindex="-1">类之间的关系 <a class="header-anchor" href="#类之间的关系" aria-label="Permalink to &quot;类之间的关系&quot;">​</a></h2><p>类之间的关系主要包含有六种。</p><h3 id="泛化-generalization" tabindex="-1">泛化（Generalization） <a class="header-anchor" href="#泛化-generalization" aria-label="Permalink to &quot;泛化（Generalization）&quot;">​</a></h3><p>表示一个类是另一个类的子类，用一条带三角箭头的实线表示。</p><p>如下图表示（A 继承自 B）：</p><p><img src="'+r+'" alt="generalization"></p><h3 id="实现-realization" tabindex="-1">实现（Realization） <a class="header-anchor" href="#实现-realization" aria-label="Permalink to &quot;实现（Realization）&quot;">​</a></h3><p>表示一个类实现了一个接口，用一条带三角箭头的虚线表示。</p><p><img src="'+o+'" alt="realize"></p><h3 id="关联-association" tabindex="-1">关联（Association） <a class="header-anchor" href="#关联-association" aria-label="Permalink to &quot;关联（Association）&quot;">​</a></h3><p>表示一个类与另一个类之间的关系，用一条直线表示。</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示 A 知道 B，但 B 不知道 A：</p><p><img src="'+s+'" alt="Association"></p><p>在最终代码中，关联对象通常是以成员变量的形式实现的。</p><h3 id="聚合-aggregation" tabindex="-1">聚合（Aggregation） <a class="header-anchor" href="#聚合-aggregation" aria-label="Permalink to &quot;聚合（Aggregation）&quot;">​</a></h3><p>与组合关系一样，同样表示整体由部分构成的语义，用一条带空心菱形的直线表示。</p><p><img src="'+n+'" alt="Aggregation"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在。</p></div><h3 id="组合-composition" tabindex="-1">组合（Composition） <a class="header-anchor" href="#组合-composition" aria-label="Permalink to &quot;组合（Composition）&quot;">​</a></h3><p>表示一个类包含另一个类的实例，用一条带实心菱形的直线表示。</p><p><img src="'+p+'" alt="Composition"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。例如，公司由多个部门组成。</p></div><h3 id="依赖-dependency" tabindex="-1">依赖（Dependency） <a class="header-anchor" href="#依赖-dependency" aria-label="Permalink to &quot;依赖（Dependency）&quot;">​</a></h3><p>表示一个类依赖于另一个类，用一条带箭头的虚线表示。</p><p>如下图表示 A 依赖于 B：</p><p><img src="'+c+'" alt="Dependency"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>依赖关系是临时性的关系，在最终代码中，通常表现为某个类的方法的参数使用了另外一个类的对象，箭头的指向为调用关系。</p></div><h2 id="时序图" tabindex="-1">时序图 <a class="header-anchor" href="#时序图" aria-label="Permalink to &quot;时序图&quot;">​</a></h2><p>时序图是一种用来展示对象之间交互的图，它描述了对象之间的消息传递顺序。</p><p>时序图包括的建模元素主要有：</p><ul><li>角色(Actor)：表示参与者，用一个人形图标表示。</li><li>对象(Object)：表示系统中的对象，用一个矩形图标表示。对象的命名方式一般有三种（名称下面都有下划线）： <ul><li>对象名和类名；</li><li>只显示对象名，不显示类名；</li><li>只显示类名，不显示对象，即为一个匿名类。</li></ul></li></ul><p><img src="'+d+'" alt="Object"></p><ul><li>生命线（Lifeline）：表示对象的生命周期，用一条竖直的虚线表示。</li><li>控制焦点（Focus of control）：表示对象执行操作的时刻，以一个很窄的矩形表示。</li><li>消息（Message）：表示对象之间的交互，主要有五种： <ul><li>简单消息：泛指对象之间的任何消息调用或发送，而不必关心是异步还是同步的；</li><li>同步消息：对象发送消息后，需要接收消息的对象响应完毕并返回消息时才会进行其余的工作；</li><li>异步消息：对象发送消息后，不需要接收消息的对象响应完毕并返回消息时就会进行其余的工作；</li><li>自返消息：是简单消息的一种，不过是对象向自己发送消息。</li><li>返回消息。</li></ul></li></ul><p><img src="'+h+'" alt="message type"></p><p>下面是一个图书馆借阅系统时序图的例子：</p><p><img src="'+m+'" alt="图书馆借阅系统时序图"></p><h2 id="作图工具" tabindex="-1">作图工具 <a class="header-anchor" href="#作图工具" aria-label="Permalink to &quot;作图工具&quot;">​</a></h2><p>UML 类图和时序图的工具主要有：</p><ul><li><a href="https://app.diagrams.net/" target="_blank" rel="noreferrer">draw.io</a></li><li><a href="https://plantuml.com/zh/" target="_blank" rel="noreferrer">PlantUML</a></li><li><a href="https://www.processon.com/" target="_blank" rel="noreferrer">ProcessOn</a></li><li><a href="https://staruml.io/" target="_blank" rel="noreferrer">StarUML</a></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>UML 类图和时序图是软件工程中不可或缺的一部分，它们可以帮助我们更好地理解系统的结构和行为，从而提高系统的可维护性和可扩展性。</p><p>在实际开发中，我们可以根据具体的需求来选择合适的 UML 类图和时序图，从而更好地完成系统的设计和开发。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://design-patterns.readthedocs.io/zh-cn/latest/read_uml.html" target="_blank" rel="noreferrer">看懂 UML 类图和时序图 — Graphic Design Patterns</a></li><li><a href="https://segmentfault.com/a/1190000021317534" target="_blank" rel="noreferrer">java - 终于明白六大类 UML 类图关系了 - 个人文章 - SegmentFault 思否</a></li><li><a href="https://www.processon.com/knowledge/sequencediagram" target="_blank" rel="noreferrer">『这就是 UML！』系列内容第 7 讲：时序图 - ProcessOn 知识社区</a></li></ul>',51)]))}const L=e(g,[["render",u]]);export{x as __pageData,L as default};
