import{_ as s,o as a,c as n,Q as p}from"./chunks/framework.e9126b17.js";const h=JSON.parse('{"title":"避免使用 #define","description":"","frontmatter":{},"headers":[],"relativePath":"effective-cpp/02-avoid-define.md","filePath":"effective-cpp/02-avoid-define.md","lastUpdated":1713013087000}'),l={name:"effective-cpp/02-avoid-define.md"},o=p(`<h1 id="避免使用-define" tabindex="-1">避免使用 #define <a class="header-anchor" href="#避免使用-define" aria-label="Permalink to &quot;避免使用 #define&quot;">​</a></h1><p>尽量使用常量、枚举和内联函数代替 <code>#define</code>。或者说尽量使用编译器，而不是预处理器。因为后者定义的宏在预处理阶段就会被替换。</p><h2 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to &quot;常量&quot;">​</a></h2><p>在下面的示例中，宏 ASPECT 定义了常量 1.653，在编译时预处理器会将所有 ASPECT 替换为 1.653，所以在编译阶段出现了问题将看不到 ASPECT 的说明，只能看到魔法数字 1.653。</p><p>解决之道是以一个常量替换上述的宏：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// bad</span></span>
<span class="line"><span style="color:#F97583;">#define</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ASPECT</span><span style="color:#E1E4E8;"> RATIO 1.653 // 宏通常用全大写名称</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// better</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">double</span><span style="color:#E1E4E8;"> AspectRatio </span><span style="color:#79B8FF;">1.653</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// bad</span></span>
<span class="line"><span style="color:#D73A49;">#define</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ASPECT</span><span style="color:#24292E;"> RATIO 1.653 // 宏通常用全大写名称</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// better</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">double</span><span style="color:#24292E;"> AspectRatio </span><span style="color:#005CC5;">1.653</span><span style="color:#24292E;">;</span></span></code></pre></div><p><code>#defines</code> 并不重视作用域。一旦宏被定义，它就在其后的编译过程中有效（除非在某处被 #undef）。</p><h2 id="宏" tabindex="-1">宏 <a class="header-anchor" href="#宏" aria-label="Permalink to &quot;宏&quot;">​</a></h2><p>另一个常见的 <code>#define</code> 误用情况是以它实现宏。</p><p>宏看起来像函数，但不会招致函数调用带来的额外开销。下面这个宏夹带着宏实参，调用函数 f:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#define</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CALL_WITH_MAX</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) f((a) &gt; (b) ? (a) : (b))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#define</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CALL_WITH_MAX</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) f((a) &gt; (b) ? (a) : (b))</span></span></code></pre></div><p>在这里，调用 f 之前，a 的递增次数竟然取决于“它被拿来和谁比较”：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#B392F0;">CALL_WITH_MAX</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">a, b);</span><span style="color:#6A737D;">      // a 被累加二次</span></span>
<span class="line"><span style="color:#B392F0;">CALL_WITH_MAX</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">a, b </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;"> // a 被累加一次</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6F42C1;">CALL_WITH_MAX</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">a, b);</span><span style="color:#6A737D;">      // a 被累加二次</span></span>
<span class="line"><span style="color:#6F42C1;">CALL_WITH_MAX</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">a, b </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span><span style="color:#6A737D;"> // a 被累加一次</span></span></code></pre></div><p>为了获得宏带来的效率以及一般函数的所有可预料行为和类型安全性，最好写出 template inline 函数：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">// 由于我们不知道 T 是什么，所以采用 pass  by  reference-to-const.</span></span>
<span class="line"><span style="color:#F97583;">inline</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">callwithMax</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;"> //</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(a </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> b);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;"> &lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">// 由于我们不知道 T 是什么，所以采用 pass  by  reference-to-const.</span></span>
<span class="line"><span style="color:#D73A49;">inline</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">callwithMax</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#E36209;">b</span><span style="color:#24292E;">)</span><span style="color:#6A737D;"> //</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(a </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> b);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这个 template 产出一整群函数，每个函数都接受两个同型对象，并以其中较大者作为实参调用 f。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><ul><li>对于单纯常量，最好以 const 对象或 enums 替换 <code>#defines</code>。</li><li>对于形似函数的宏，最好改用 inline 函数替换 <code>#defines</code>。</li></ul>`,18),e=[o];function c(t,r,y,E,i,d){return a(),n("div",null,e)}const F=s(l,[["render",c]]);export{h as __pageData,F as default};
