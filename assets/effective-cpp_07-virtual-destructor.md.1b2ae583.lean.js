import{_ as a,o as l,c as n,O as p}from"./chunks/framework.2a7ed5c6.js";const u=JSON.parse('{"title":"为基态类声明 virtual 析构函数","description":"","frontmatter":{},"headers":[],"relativePath":"effective-cpp/07-virtual-destructor.md","filePath":"effective-cpp/07-virtual-destructor.md","lastUpdated":1743313216000}'),e={name:"effective-cpp/07-virtual-destructor.md"};function o(c,s,t,r,i,E){return l(),n("div",null,s[0]||(s[0]=[p(`<h1 id="为基态类声明-virtual-析构函数" tabindex="-1">为基态类声明 virtual 析构函数 <a class="header-anchor" href="#为基态类声明-virtual-析构函数" aria-label="Permalink to &quot;为基态类声明 virtual 析构函数&quot;">​</a></h1><p>C++ 指出，当 derived class 对象经由一个 base class 指针被删除，而该 base class 带着一个 non-virtual 析构函数，其结果是未定义的。<em>实际执行时通常发生的是对象的 derived 成分没被销毁。</em></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TimeKeeper</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">TimeKeeper</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">~TimeKeeper</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicClock</span><span style="color:#E1E4E8;"> : </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TimeKeeper</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span><span style="color:#6A737D;"> // 原子钟</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">TimeKeeper </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ptk </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicClock</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TimeKeeper</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">TimeKeeper</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">~TimeKeeper</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicClock</span><span style="color:#24292E;"> : </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TimeKeeper</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">};</span><span style="color:#6A737D;"> // 原子钟</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">TimeKeeper </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ptk </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicClock</span><span style="color:#24292E;">();</span></span></code></pre></div><p>上面指针指向一个 Atomicclock 对象，其内的 AtomicClock 成分（也就是声明于 Atomicclock class 内的成员变量）很可能没被销毁，而 AtomicClock 的析构函数也未能执行起来。</p><p>然而其 base class 成分（也就是 TimeKeeper 这一部分）通常会被销毁，于是造成一个诡异的“局部销毁”对象。</p><p>消除这个问题的做法很简单，就是给 base class 一个 virtual 析构函数：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TimeKeeper</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">TimeKeeper</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">virtual</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">~TimeKeeper</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TimeKeeper</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">TimeKeeper</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">virtual</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">~TimeKeeper</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>每一个带有 virtual 函数的 class 都有一个相应的 vtbl。当对象调用某一 virtual 函数，实际被调用的函数取决于该对象的 vptr 所指的那个 vtbl——编译器在其中寻找适当的函数指针。</p><blockquote><p>vptr 是指向一个由函数指针构成的数组，称为 vtbl(virtual table)。</p></blockquote><p>所以，如果 class 不含 virtual 函数，通常表示它并不意图被用做一个 base class。当 class 不企图被当作 base class，令其析构函数为 virtual 往往是个馊主意。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><ul><li>如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。</li><li>带多态性质的 base classes 应该声明一个 virtual 析构函数。</li><li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性，就不该声明 virtual 析构函数。</li><li>如果想拥有抽象的 base class，但没有合适的纯虚函数，则可以为其声明一个纯虚析构函数。</li></ul>`,12)]))}const d=a(e,[["render",o]]);export{u as __pageData,d as default};
